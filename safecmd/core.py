"""Core API for safecmd"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_core.ipynb.

# %% auto 0
__all__ = ['default_cfg', 'cfg_path', 'ok_dests', 'ok_cmds', 'run', 'CmdSpec', 'parse_cfg', 'validate_cmd', 'DisallowedError',
           'DisallowedCmd', 'DisallowedDest', 'normalize_dest', 'validate_dest', 'validate', 'safe_run', 'bash',
           'unsafe_bash', 'add_allowed_cmds', 'add_allowed_dests', 'rm_allowed_cmds', 'rm_allowed_dests', 'main']

# %% ../nbs/01_core.ipynb
import subprocess,json,shutil,os
from fastcore.utils import *
from fastcore.xdg import xdg_config_home
from configparser import ConfigParser

from .bashxtract import *

# %% ../nbs/01_core.ipynb
def run(cmd, ignore_ex=False):
    "Run `cmd` in shell; return stdout (+ stderr if any); raise IOError on failure"
    res = subprocess.run(cmd, shell=True, capture_output=True, text=True)
    out = res.stdout.strip()
    if res.stderr: out += ('\n' if out else '') + res.stderr.strip()
    if ignore_ex: return (res.returncode, out)
    if res.returncode: raise IOError(out)
    return out

# %% ../nbs/01_core.ipynb
class CmdSpec(BasicRepr):
    def __init__(self,
        name,  # the command (str, will be split into tuple)
        denied=None):  # if set, these flags blocked
        self.name = tuple(name.split())
        self.denied = set(denied or [])

    @classmethod
    def from_str(cls, s):
        "Create from 'cmd:-flag1,-flag2' format"
        name, _, denied = s.partition(':')
        return cls(name, denied.split('|') if denied else None)
        
    def __hash__(self): return hash(self.name)
    def __eq__(self, b): return self.name==b.name
    
    def __repr__(self):
        s = ' '.join(self.name)
        if self.denied: s += f' !{self.denied}'
        return s
    
    def __call__(self, toks):
        "Returns True if allowed, False if no match or denied flag found"
        if tuple(toks[:len(self.name)]) != self.name: return False
        if not self.denied: return True
        for d in self.denied:
            if d in toks: return False  # exact match
            # Long flag with =value: --flag=value matches --flag
            if d.startswith('--'):
                if any(tok.startswith(d + '=') for tok in toks): return False
            # Single-letter short flag: check if letter appears in any combined -xyz arg
            elif len(d) == 2 and d[0] == '-':
                for tok in toks:
                    if tok.startswith('-') and not tok.startswith('--') and d[1] in tok[1:]: return False
        return True

# %% ../nbs/01_core.ipynb
default_cfg = '''[DEFAULT]
ok_dests = ./, /tmp

ok_cmds = cat, head, tail, less, more, bat
    # Directory listing
    ls, tree, locate
    # Search
    grep, rg, ag, ack, fgrep, egrep
    # Text processing
    cut, sort, uniq, wc, tr, column
    # File info
    file, stat, du, df, which, whereis, type
    # Comparison
    diff, cmp, comm
    # Archives
    unzip, gunzip, bunzip2, unrar
    # Network
    ping, dig, nslookup, host
    # System info
    date, cal, uptime, whoami, hostname, uname, printenv
    # Utilities
    echo, printf, yes, seq, basename, dirname, realpath
    # Git (read-only)
    git log, git show, git diff, git status, git branch, git tag, git remote,
    git stash list, git blame, git shortlog, git describe, git rev-parse,
    git ls-files, git ls-tree, git cat-file, git config --get, git config --list
    # Git (workspace)
    git fetch, git add, git commit, git switch, git checkout
    # Builtins
    cd, pwd, export, test, [, true, false
    # Deny-lists
    find:-exec|-execdir|-delete|-ok|-okdir
    rg:--pre
    tar:--to-command|--use-compress-program|-I|--transform|--checkpoint-action|--info-script|--new-volume-script
    curl:-o|--output|-O|--remote-name
'''

# %% ../nbs/01_core.ipynb
cfg_path = xdg_config_home() / 'safecmd' / 'config.ini'
if not cfg_path.exists(): cfg_path.mk_write(default_cfg)

# %% ../nbs/01_core.ipynb
def _split_set(s):
    "Split comma-separated string into set of stripped strings"
    return {o.strip() for o in s.split(',')} if s else set()

def _split_specs(s):
    "Split comma-separated string into set of CmdSpecs"
    return {CmdSpec.from_str(c.strip()) for c in s.split(',') if c.strip()} if s else set()

def parse_cfg(cfg_str):
    "Parse config string, return (ok_dests set, ok_cmds set of CmdSpecs)"
    cp = ConfigParser()
    cp.read_string(cfg_str)
    cfg = cp['DEFAULT']
    ok_dests = _split_set(cfg.get('ok_dests', './, /tmp'))
    splitcmds = ','.join(cfg['ok_cmds'].splitlines())
    ok_cmds = _split_specs(splitcmds)
    return ok_dests, ok_cmds

# %% ../nbs/01_core.ipynb
ok_dests,ok_cmds = parse_cfg(cfg_path.read_text())

# %% ../nbs/01_core.ipynb
def validate_cmd(toks, cmds=None):
    "Check if toks matches an allowed command; returns False if denied flags present"
    if cmds is None: cmds = ok_cmds
    return any(spec(toks) for spec in cmds)

# %% ../nbs/01_core.ipynb
class DisallowedError(PermissionError):
    def __repr__(self): return f"{type(self).__name__}({self.args[0]!r})"

class DisallowedCmd(DisallowedError):
    def __init__(self, cmd): super().__init__(' '.join(cmd))

class DisallowedDest(DisallowedError):
    def __init__(self, dest): super().__init__(dest)

# %% ../nbs/01_core.ipynb
def normalize_dest(dest):
    "Normalize destination to absolute path, expanding ~ and env vars"
    dest = os.path.expanduser(dest)
    dest = os.path.expandvars(dest)
    return os.path.normpath(os.path.abspath(dest))

def validate_dest(dest, dests=None):
    "Check if dest (resolved to absolute) matches an allowed destination pattern"
    if dests is None: dests = ok_dests
    abs_dest = normalize_dest(dest)
    for pattern in dests:
        abs_pattern = normalize_dest(pattern)
        if abs_dest.startswith(abs_pattern): return True
    return False

# %% ../nbs/01_core.ipynb
def validate(
    cmd:str,  # Bash command string to validate
    cmds=None,  # Allowed commands set; defaults to ok_cmds
    dests=None,  # Allowed destinations set; defaults to ok_dests
):
    "Validate `cmd` against allowlists; raises DisallowedCmd or DisallowedDest on failure"
    if cmds is None: cmds = ok_cmds
    if dests is None: dests = ok_dests
    commands, ops, redirects = extract_commands(cmd)
    for c in commands:
        if not validate_cmd(c, cmds): raise DisallowedCmd(c)
    for op, dest in redirects:
        if not validate_dest(dest, dests): raise DisallowedDest(dest)

# %% ../nbs/01_core.ipynb
def safe_run(
    cmd:str,  # Bash command string to execute
    cmds:str=None,  # Allowed commands (comma-separated, config format); defaults to ok_cmds
    dests:str=None,  # Allowed destinations (comma-separated); defaults to ok_dests
    add_cmds:str=None,  # Temp add these commands
    add_dests:str=None,  # Temp add these destinations
    rm_cmds:str=None,  # Temp remove these commands
    rm_dests:str=None,  # Temp remove these destinations
    ignore_ex:bool=False,  # If True, return (returncode, output) instead of raising on error
) -> str:  # Combined stdout/stderr output
    "Run `cmd` in shell if all commands and destinations are in allowlists, else raise"
    eff_dests = _split_set(dests) if dests else ok_dests.copy()
    eff_cmds = _split_specs(cmds) if cmds else ok_cmds.copy()
    
    eff_dests |= _split_set(add_dests)
    eff_dests -= _split_set(rm_dests)
    eff_cmds |= _split_specs(add_cmds)
    eff_cmds -= {CmdSpec(c) for c in _split_set(rm_cmds)}
    
    validate(cmd, eff_cmds, eff_dests)
    return run(cmd, ignore_ex=ignore_ex)

# %% ../nbs/01_core.ipynb
def bash(
    cmd:str,  # Bash command string to execute - all shell features like pipes and subcommands are supported
    rm_cmds:str=None,  # Temp remove these commands from allow list
    rm_dests:str=None  # Temp remove these destinations from allow list
): # dict with 'success' or 'error' key; value is stdout+stderr for success, or error message otherwise
    """Run a bash shell command line safely and return the concatencated stdout and stderr.
    `cmd` is parsed and all calls are checked against an allow-list.
    If the command is not allowed, STOP and inform the user of the command run and error details; so they can decide whether to whitelist
    it or run it themselves.
    The default allow-list includes most standard unix commands and git subcommands that do not change state or are easily reverted.
    All operators are supported. Output redirects are validated against allowed destinations (default: ./ and /tmp).
    rm_ params are comma-separated strs."""
    try: return {'success': safe_run(cmd, rm_cmds=rm_cmds, rm_dests=rm_dests)}
    except PermissionError as e: return {'error': e}

# %% ../nbs/01_core.ipynb
def unsafe_bash(
    cmd:str,  # Bash command string to execute - all shell features like pipes and subcommands are supported
    cmds:str=None,  # Allowed commands; defaults to ok_cmds; DO NOT USE without upfront user permission
    dests:str=None,  # Allowed destinations; defaults to ok_dests; DO NOT USE without upfront user permission
    add_cmds:str=None,  # Temp add these commands to allow list; DO NOT USE without upfront user permission
    add_dests:str=None,  # Temp add these destinations to allow list; DO NOT USE without upfront user permission
    rm_cmds:str=None,  # Temp remove these commands from allow list
    rm_dests:str=None,  # Temp remove these destinations from allow list
): # dict with 'success' or 'error' key; value is stdout+stderr for success, or error message otherwise
    """Run a bash shell command line safely and return the output. `cmd` is parsed and all calls are checked against an allow-list.
    If the command is not allowed, STOP and inform the user of the command run and error details; so they can decide whether to whitelist
    it or run it themselves.
    The default allow-list includes most standard unix commands and git subcommands that do not change state or are easily reverted.
    All operators are supported. Output redirects are validated against allowed destinations.
    cmds/dests and add_/rm_ params are comma-separated strs."""
    try: return {'success': safe_run(cmd, cmds, dests, add_cmds=add_cmds, add_dests=add_dests, rm_cmds=rm_cmds, rm_dests=rm_dests)}
    except PermissionError as e: return {'error': e}

# %% ../nbs/01_core.ipynb
def add_allowed_cmds(cmds):
    "Add comma-separated `cmds` to the allow list; (this can not be used as an LLM tool)"
    ok_cmds.update(_split_specs(cmds))

def add_allowed_dests(dests):
    "Add comma-separated `dests` to the allow list; (this can not be used as an LLM tool)"
    ok_dests.update(_split_set(dests))

def rm_allowed_cmds(cmds:str):
    "Remove comma-separated `cmds` from the allow list"
    ok_cmds.difference_update({CmdSpec(c) for c in _split_set(cmds)})

def rm_allowed_dests(dests):
    "Remove comma-separated `dests` from the allow list"
    ok_dests.difference_update(_split_set(dests))

# %% ../nbs/01_core.ipynb
import argparse,sys

# %% ../nbs/01_core.ipynb
def main():
    p = argparse.ArgumentParser(description='Run a command (kinda) safely')
    p.add_argument('cmd', nargs=argparse.REMAINDER, help='Command and arguments')
    args = p.parse_args()
    if not args.cmd: p.print_help(); sys.exit(1)
    try: print(safe_run(' '.join(args.cmd)))
    except DisallowedError as e: print(f"Command not allowed: {e}", file=sys.stderr); sys.exit(1)
