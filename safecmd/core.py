"""Core API for safecmd"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_core.ipynb.

# %% auto 0
__all__ = ['default_cfg', 'cfg_path', 'ok_ops', 'ok_cmds', 'run', 'CmdSpec', 'add_cmds', 'parse_cfg', 'validate_cmd',
           'DisallowedOps', 'DisallowedCmd', 'safe_run']

# %% ../nbs/01_core.ipynb 1
import subprocess,json,shutil
from fastcore.utils import *
from fastcore.xdg import xdg_config_home
from configparser import ConfigParser

from .bashxtract import *

# %% ../nbs/01_core.ipynb 11
def run(cmd, ignore_ex=False):
    "Run `cmd` in shell; return stdout (+ stderr if any); raise IOError on failure"
    res = subprocess.run(cmd, shell=True, capture_output=True, text=True)
    out = res.stdout.strip()
    if res.stderr: out += ('\n' if out else '') + res.stderr.strip()
    if ignore_ex: return (res.returncode, out)
    if res.returncode: raise IOError(out)
    return out

# %% ../nbs/01_core.ipynb 16
class CmdSpec(BasicRepr):
    def __init__(self,
        name,  # the command (str, will be split into tuple)
        denied=None):  # if set, these flags blocked
        self.name = tuple(name.split())
        self.denied = set(denied or [])

    @classmethod
    def from_str(cls, s):
        "Create from 'cmd:-flag1,-flag2' format"
        name, _, denied = s.partition(':')
        return cls(name, denied.split('|') if denied else None)
        
    def __hash__(self): return hash(self.name)
    def __eq__(self, b): return self.name==b.name
    
    def __repr__(self):
        s = ' '.join(self.name)
        if self.denied: s += f' !{self.denied}'
        return s
    
    def __call__(self, toks):
        "Returns True if allowed, False if no match or denied flag found"
        if tuple(toks[:len(self.name)]) != self.name: return False
        return not (self.denied and self.denied & set(toks))

# %% ../nbs/01_core.ipynb 22
def add_cmds(*cmds):
    ok_cmds.update(c if isinstance(c, CmdSpec) else CmdSpec(c) for c in cmds)

# %% ../nbs/01_core.ipynb 26
default_cfg = '''[DEFAULT]
ok_ops = |, <, &&, ||, ;

ok_cmds = cat, head, tail, less, more, bat
    # Directory listing
    ls, tree, locate
    # Search
    grep, rg, ag, ack, fgrep, egrep
    # Text processing
    cut, sort, uniq, wc, tr, column
    # File info
    file, stat, du, df, which, whereis, type
    # Comparison
    diff, cmp, comm
    # Archives
    tar, unzip, gunzip, bunzip2, unrar
    # Network
    curl, wget, ping, dig, nslookup, host
    # System info
    date, cal, uptime, whoami, hostname, uname, env, printenv
    # Utilities
    echo, printf, yes, seq, basename, dirname, realpath
    # Git (read-only)
    git log, git show, git diff, git status, git branch, git tag, git remote,
    git stash list, git blame, git shortlog, git describe, git rev-parse,
    git ls-files, git ls-tree, git cat-file, git config --get, git config --list
    # Git (workspace)
    git fetch, git add, git commit, git switch, git checkout
    # Find with deny-list
    find:-exec|-execdir|-delete|-ok|-okdir
'''

# %% ../nbs/01_core.ipynb 27
cfg_path = xdg_config_home() / 'safecmd' / 'config.ini'
if not cfg_path.exists(): cfg_path.mk_write(default_cfg)

# %% ../nbs/01_core.ipynb 29
def parse_cfg(cfg_str):
    "Parse config string, return (ok_ops set, ok_cmds set of CmdSpecs)"
    cp = ConfigParser()
    cp.read_string(cfg_str)
    cfg = cp['DEFAULT']
    ok_ops = {o.strip() for o in cfg['ok_ops'].split(',')}
    splitcmds = ','.join(cfg['ok_cmds'].splitlines()).split(',')
    ok_cmds = {CmdSpec.from_str(c.strip()) for c in splitcmds if c.strip()}
    return ok_ops, ok_cmds

# %% ../nbs/01_core.ipynb 30
ok_ops,ok_cmds = parse_cfg(cfg_path.read_text())

# %% ../nbs/01_core.ipynb 34
def validate_cmd(toks, cmds=None):
    "Check if toks matches an allowed command; returns False if denied flags present"
    if cmds is None: cmds = ok_cmds
    return any(spec(toks) for spec in cmds)

# %% ../nbs/01_core.ipynb 37
class DisallowedOps(PermissionError):
    def __init__(self, ops): super().__init__(f"{ops}")

class DisallowedCmd(PermissionError):
    def __init__(self, cmd): super().__init__(' '.join(cmd))

def safe_run(cmd, cmds=None, ops=None):
    "Run `cmd` in shell if all commands and operators are in allowlists, else raise"
    if ops is None: ops = ok_ops
    commands, used_ops = extract_commands(cmd)
    if bad_ops := used_ops - ops: raise DisallowedOps(bad_ops)
    for c in commands:
        if not validate_cmd(c, cmds): raise DisallowedCmd(c)
    return run(cmd)
